# Пользовательский пул потоков (CustomThreadPool)

## О проекте

Это собственная реализация пула потоков для Java-приложений с высокой нагрузкой. Поддерживаются:

- **Тонкая настройка параметров**:
  - `corePoolSize` — минимальное количество потоков
  - `maxPoolSize` — максимальное количество потоков
  - `keepAliveTime` + `TimeUnit` — время простоя «лишних» потоков до завершения
  - `minSpareThreads` — минимальное число «резервных» потоков, которые всегда готовы взять задачу
  - `queueSize` — размер каждой внутренней очереди
- **Несколько очередей задач и Round-Robin-балансировка**
- **Расширяемые политики отказа** (Reject Policy)
- **Детальное логирование** жизненного цикла потоков и задач
- **Корректное завершение работы** (`shutdown()` и `shutdownNow()`)

---

## 1. Архитектура решения

**CustomExecutor (интерфейс)**  
Контракт, совместимый с `java.util.concurrent.Executor`. Поддерживает методы:
- `execute(Runnable)`
- `submit(Callable<T>)`
- `shutdown()`
- `shutdownNow()`

**CustomThreadPoolExecutor**  
- Принимает задачи и распределяет их по внутренним очередям по принципу Round-Robin
- Динамически масштабирует пул от `corePoolSize` до `maxPoolSize` (и уменьшает обратно по таймауту простоя)
- Обеспечивает потокобезопасность через `synchronized`
- Логирует ключевые события: создание/завершение потоков, постановка и выполнение задач, отказы

**TaskQueue** (одна на каждый Worker)  
- Обёртка над `ArrayBlockingQueue<Runnable>` с фиксированным размером (`queueSize`)
- Метод `offer(task)` — неблокирующая вставка задачи (true/false)
- Метод `poll(timeout, unit)` — ожидание задачи до `keepAliveTime`
- Метод `drainTo(...)` — сбор оставшихся задач для `shutdownNow()`

**Worker**  
- Цикл: ждет задачу с помощью `poll(keepAliveTime)`, проверяет флаг завершения, выполняет `run()`
- Если `poll()` вернул `null` (таймаут), и число потоков > `corePoolSize`, поток завершает себя
- Перед каждой задачей проверяет `shutdownFlag` для гарантии корректного завершения

**CustomThreadFactory**  
- Создаёт потоки с именем `<PoolName>-worker-N`
- Устанавливает daemon-флаг
- Регистрирует обработчик необработанных исключений (`UncaughtExceptionHandler`)

**Балансировка**  
Выполняется на уровне CustomThreadPoolExecutor с помощью атомарного счётчика:


idx = nextIdx.getAndIncrement() % queues.size()
q = queues.get(idx)

Это обеспечивает O(1)-распределение задач между очередями.

---

## 2. Балансировка задач

- **Round-Robin** — каждая задача поступает в очередь воркера по кругу.  
- Если очередь заполнена, а число потоков < `maxPoolSize`, создаётся новый воркер с новой очередью (и повторяется попытка добавить задачу).
- Если добавить задачу не удалось и после этого — вызывается политика отказа (см. ниже).

**Почему не Least-Loaded?**  
На коротких задачах затраты на подсчёт размеров очередей (O(N)) сравнимы с самой обработкой задачи. Round-Robin (O(1)) обеспечивает предсказуемую и быструю работу.

---

## 3. Политика отказов

Используется **AbortPolicy** (задача отвергается):

```java
private void reject(Runnable task) {
    System.out.printf("[Rejected] Task %s was rejected due to overload!%n", task);
    throw new RejectedExecutionException("Task rejected: " + task);
}
````

**Аргументация**:

* Исключение сразу сообщает клиенту, что задача не принята
* `execute()` всегда отрабатывает быстро и предсказуемо (O(1)), независимо от содержимого задачи
* Такое поведение легко тестировать

**Недостатки**:

* Потерянные задачи (если клиент не ловит исключение)
* Много отказов — «шум» в логах (на проде стоит агрегировать/троттлить сообщения)
* Нет «мягкой деградации» (например, выполнение в вызывающем потоке)

---

## 4. Производительность (кратко)

* **Короткие I/O-задачи**: чуть быстрее обычного пула (`FixedThreadPool(4)`), преимущество 5–10%. Помогает `minSpareThreads`, который держит резерв свободных потоков.
* **Чистый CPU**: примерно так же, как и стандартный пул (ограничение — количество ядер процессора).
* **Память (RSS)**: использование на 5–10 МБ больше, т.к. «временные» потоки живут до `idle-timeout` (например, 5 секунд).

---

## 5. Исследование параметров

* **corePoolSize** — линейный рост пропускной способности до числа логических ядер, дальше замедляется из-за переключений контекста.
* **maxPoolSize** — для I/O-задач хорошо ставить `corePoolSize × 2`, выше нет смысла.
* **queueSize** — увеличение с 1 до 3 уменьшает задержку, дальше только увеличивает резерв задач.
* **keepAliveTime** — 5 секунд: баланс между сохранением резервных потоков и экономией ресурсов.
* **minSpareThreads** — 1 поток убирает «холодный старт», от 2 и больше заметного эффекта нет.

---

## 6. Пример использования

```java
CustomThreadPoolExecutor pool = new CustomThreadPoolExecutor(
    2,                    // corePoolSize
    4,                    // maxPoolSize
    5, TimeUnit.SECONDS,  // keepAliveTime = 5 секунд
    3,                    // queueSize на каждый воркер
    1,                    // minSpareThreads (резервный поток)
    "DemoPool"            // имя пула (для логов)
);

pool.execute(() -> {
    // Работа задачи
});

pool.shutdown(); // Ждём завершения всех задач
```

---

## 7. Пример логов

```
[ThreadFactory] Creating new thread: DemoPool-worker-3
[Pool] Task accepted into queue #2: Task@1e80bfe8
[Worker] DemoPool-worker-2 executes Task@1e80bfe8
[Rejected] Task Task@5e9f23b4 was rejected due to overload!
[Worker] DemoPool-worker-3 idle timeout (5 000 ms), stopping.
```

---

## 8. Как попробовать

Соберите и запустите проект так:

```bash
javac *.java
java Main
```

В демонстрационной программе показаны:

* Обычная работа с раздачей задач
* Перегрузка пула и обработка отказов
* Корректное завершение через shutdown и shutdownNow
