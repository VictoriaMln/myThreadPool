# Пользовательский пул потоков (CustomThreadPool)

## О проекте

Собственная реализация пула потоков для Java-приложений с высокой нагрузкой.  
  
  Возможности:

- **Гибкая настройка**:
  - `corePoolSize` — минимальное количество потоков
  - `maxPoolSize` — максимум потоков, которые может создать пул
  - `keepAliveTime` + `TimeUnit` — время простоя «лишних» потоков до завершения
  - `minSpareThreads` — минимальное число «резервных» потоков, которые всегда готовы взять задачу
  - `queueSize` — сколько задач держит каждая очередь
- **Несколько очередей и балансировка задач по принципу Round-Robin**
- **Настраиваемая политика отказа** (по умолчанию — задачи просто отклоняются)
- **Подробное логирование** жизненного цикла потоков и задач
- **Корректное завершение работы** (через `shutdown()` и экстренное через `shutdownNow()`)

---

## 1. Архитектура решения

**CustomExecutor (интерфейс)**  
Обеспечивает инерфейс работы с пулом, поддерживает методы:
- `execute(Runnable)`
- `submit(Callable<T>)`
- `shutdown()`
- `shutdownNow()`

**CustomThreadPoolExecutor**  
- Принимает задачи и распределяет их по внутренним очередям (одна очередь — один воркер)
- Динамически масштабирует пул от `corePoolSize` до `maxPoolSize` (и уменьшает обратно по таймауту простоя)
- Гарантирует безопасность при работе в многопоточной среде через `synchronized`
- Логирует все важные события

**TaskQueue**  
- Обёртка над `ArrayBlockingQueue<Runnable>` с фиксированным размером (`queueSize`)
- Для каждого воркера — своя очередь, для снижения «конкуренции» между потоками
- Можно быстро добавить задачу (`offer`) или забрать на выполнение (`poll`)
- Метод `drainTo(...)` — сбор оставшихся задач при завершении пула

**Worker**  
- Рабочий поток ждёт задачу в своей очереди, выполняет её и снова ждёт
- Если поток простаивает слишком долго, а потоков больше, чем нужно — он завершает свою работу
- Перед каждой задачей проверяет `shutdownFlag` для гарантии корректного завершения

**CustomThreadFactory**  
- Создаёт потоки с уникальным именем (`<PoolName>-worker-N`)
- Устанавливает daemon-флаг
- Для всех потоков настраивается обработчик необработанных исключений (`UncaughtExceptionHandler`)

**Балансировка**  
- Выполняется на уровне CustomThreadPoolExecutor с помощью атомарного счётчика:

  idx = nextIdx.getAndIncrement() % queues.size()
  
  q = queues.get(idx)

Такое распределение позволяет избежать перегрузки отдельных очередей и даёт равномерную загрузку всех воркеров.

---

## 2. Балансировка задач

- **Round-Robin** — все задачи равномерно распределяются по очередям (воркерам) с помощью простого счётчика.
- Если очередь уже переполнена, а общее число потоков ещё не достигло максимума — пул добавит ещё один поток и повторит попытку добавить задачу.
- Если даже после этого очередь заполнена — задача будет отклонена
  
**Плюсы Round-Robin**
- Простая и дешевая схема: каждый вызов — одна операция деления по модулю.  
- Равномерное распределение задач, нет «горячих точек» на одной очереди.  
- Подходит для случаев, когда задачи примерно одинаковые по нагрузке.
---

## 3. Политика отказов

Используется **AbortPolicy** (задача отвергается):

```java
private void reject(Runnable task) {
    System.out.printf("[Rejected] Task %s was rejected due to overload!%n", task);
    throw new RejectedExecutionException("Task rejected: " + task);
}
````

**Плюсы выбранного подхода**:

* Исключение сразу сообщает клиенту, что задача не принята
* Гарантировано быстрое выполнение метода `execute()` — нет скрытых задержек
* Такое поведение легко проверять тестами

**Недостатки**:

* Потерянные задачи (если клиент не ловит исключение)
* При большом количестве отказов логи могут быстро разрастаться (в реальных системах стоит ограничивать такие сообщения)
* Нет «мягкой деградации» (например, выполнение в вызывающем потоке)

---

## 4. Производительность

* **Короткие I/O-задачи**: пул работает чуть быстрее стандартного, потому что резервные потоки всегда готовы принять новую работу.
* **Чистый CPU**: примерно так же, как и стандартный пул (ограничение — количество ядер процессора).
* **Память (RSS)**: в среднем используется на 5–10 МБ больше, потому что временные потоки держатся в памяти чуть дольше.

---

## 5. Параметры конфигурации

* **corePoolSize** — оптимально ставить = количество логических ядер (до этого значения растёт пропускная способность).
* **maxPoolSize** — для I/O-задач оптимально устанавливать `corePoolSize × 2`.
* **queueSize** — увеличение с 1 до 3 уменьшает задержку, дальше увеличивает резерв задач.
* **keepAliveTime** — 5 секунд: баланс между сохранением резервных потоков и экономией ресурсов.
* **minSpareThreads** — обычно достаточно одного резервного потока.

---

## 6. Пример использования

```java
CustomThreadPoolExecutor pool = new CustomThreadPoolExecutor(
    2,                    // corePoolSize
    4,                    // maxPoolSize
    5, TimeUnit.SECONDS,  // keepAliveTime = 5 секунд
    3,                    // queueSize на каждый воркер
    1,                    // minSpareThreads (резервный поток)
    "DemoPool"            // имя пула (для логов)
);

pool.execute(() -> {
    // Работа задачи
});

pool.shutdown(); // Ждём завершения всех задач
```

---

## 7. Пример логов

```
[ThreadFactory] Creating new thread: DemoPool-worker-3
[Pool] Task accepted into queue #2: Task@1e80bfe8
[Worker] DemoPool-worker-2 executes Task@1e80bfe8
[Rejected] Task Task@5e9f23b4 was rejected due to overload!
[Worker] DemoPool-worker-3 idle timeout (5 000 ms), stopping.
```

---

## 8. Запуск и проверка

Необходимо собрать и запустить проект следующими командами:

```bash
javac *.java
java Main
```

В демонстрационной программе показаны:

* Обычная работа с раздачей задач
* Перегрузка пула и обработка отказов
* Корректное завершение через shutdown и shutdownNow
