# Пользовательский пул потоков (CustomThreadPool)

**О проекте.** 

Реализация собственного пула потоков для Java‑приложений с высокой нагрузкой.
Пул поддерживает:

* тонкую настройку (core/max size, keepAlive, minSpareThreads, размер очереди);
* несколько очередей задач и Round‑Robin‑балансировку;
* расширяемые политики отказа;
* детальное логирование жизненного цикла потоков и задач;
* корректное завершение работы.

---

## 1. Архитектура решения

Cхема компонентов пользовательского пула потоков и взаимодействия между ними.

| Слой                                                                                                 | Компонент                                  | Ответственность                                                                                                 |
| ---------------------------------------------------------------------------------------------------- | ------------------------------------------ | --------------------------------------------------------------------------------------------------------------- |
| **API**                                                                                              | `CustomExecutor`                           | Контракт, совместимый с `java.util.concurrent.Executor`: методы `execute`, `submit`, `shutdown`, `shutdownNow`. |
| **Менеджер пула**                                                                                    | `CustomThreadPoolExecutor`                 |                                                                                                                 |
| • хранит текущий набор рабочих потоков и их очередей                                                 |                                            |                                                                                                                 |
| • реализует стратегию масштабирования (расширение до `maxPoolSize`, сворачивание после idle‑timeout) |                                            |                                                                                                                 |
| • инкапсулирует алгоритм балансировки (Round‑Robin)                                                  |                                            |                                                                                                                 |
| • обеспечивает потокобезопасность через синхронизированные блоки по `this`                           |                                            |                                                                                                                 |
| • публикует детальные логи на всех переходах состояний                                               |                                            |                                                                                                                 |
| **Очередь задач**                                                                                    | `TaskQueue` (экземпляр на каждый `Worker`) |                                                                                                                 |
| • фиксированный размер `queueSize`                                                                   |                                            |                                                                                                                 |
| • неблокирующая вставка `offer` с возвратом результата                                               |                                            |                                                                                                                 |
| • вывод логов при постановке/отказе                                                                  |                                            |                                                                                                                 |
| • метод `drainTo()` — нужен для `shutdownNow()`                                                      |                                            |                                                                                                                 |
| **Рабочий поток**                                                                                    | `Worker`                                   |                                                                                                                 |
| • цикл: `poll` → `run` задачи                                                                        |                                            |                                                                                                                 |
| • прекращает работу, если истёк `keepAliveTime` и текущий `poolSize` > `corePoolSize`          |                                            |                                                                                                                 |
| • до запуска каждой задачи проверяет флаг `shutdownFlag`, что гарантирует «graceful shutdown»        |                                            |                                                                                                                 |
| **Фабрика потоков**                                                                                  | `CustomThreadFactory`                      |                                                                                                                 |
| • создаёт поток с уникальным именем `<PoolName>-worker-N`                                            |                                            |                                                                                                                 |
| • задаёт daemon‑флаг                                                                                 |                                            |                                                                                                                 |
| • регистрирует `UncaughtExceptionHandler` для логирования необработанных исключений                  |                                            |                                                                                                                 |


\-----------|------------|
\| **CustomThreadPoolExecutor** | Принимает задачи, раздаёт их по очередям (Round‑Robin), растит/сжимает пул, реализует `execute/submit/shutdown/shutdownNow`. |
\| **TaskQueue** (на каждый воркер) | `ArrayBlockingQueue` c лимитом и логами (`offer / poll / drainTo`). |
\| **Worker** | Берёт задачи из «своей» очереди; завершаетcя по idle‑timeout **только** если потоков > `corePoolSize`. |
\| **CustomThreadFactory** | Даёт имена вроде `DemoPool-worker-3`, логирует создание и необработанные исключения. |

---

## 2. Балансировка задач

* **Алгоритм**: простой Round‑Robin — счётчик `nextIdx` циклически выбирает очередь.
* **Почему не Least‑Loaded**: на коротких задачах затраты на подсчёт длины всех очередей сравнимы с самой работой.
* **Результат**: нагрузка распределяется равномерно, накладные расходы O(1).

---

## 3. Выбранная политика отказов

В реализации используется **политика типа *Abort***: при невозможности разместить задачу в очереди и отсутствии ресурса для увеличения пула вызывается метод `reject`, который логирует событие и выдаёт `RejectedExecutionException`.

**Аргументация выбора**

1. **Чёткий семантический сигнал**.
   Исключение немедленно прекращает цепочку вызовов в клиентском коде, не оставляя сомнений, что запрос не принят к выполнению.
2. **Постоянная временная сложность**.
   В отличие от `CallerRuns` (когда задача выполняется в потоке‑отправителе) время реакции не зависит от содержимого задачи; это критично для сервисов с жёсткими SLA на отклик.
3. **Простота верификации**.
   Поведение «принято/отклонено» легко проверяется модульным тестом, что снижает трудозатраты на сопровождение.

**Недостатки**

* *Потенциальная потеря задачи*. Если клиент не перехватил исключение, работа считается «потерянной».
* *Шум в логах во время пиковых нагрузок*. Большое количество отказов способно заполнить файл логов, поэтому рекомендуется использовать агрегацию/троттлинг сообщений.
* *Отсутствие деградации*. Системы, в которых приемлем «более долгий отклик вместо отказа», потребуют иной стратегии (напр. `CallerRuns` или `DiscardOldest`).

Таким образом выбор *Abort‑policy* оправдан сценариями, где **важнее предсказуемость времени отклика и отчётность о каждой непрошедшей задаче**, чем гарантия «не терять ни одного задания любой ценой».  При необходимости политика может быть введена через конструктор пула без изменения остального кода.

\--- Производительность 

| Нагрузка            | CustomPool                  | `FixedThreadPool(4)` | Что заметно                                                                                    |
| ------------------- | --------------------------- | -------------------- | ---------------------------------------------------------------------------------------------- |
| Короткие I/O‑задачи | **чуть быстрее** (≈ 5‑10 %) | —                    | `minSpareThreads` держит запас свободных тредов, поэтому новые задачи не ждут создания потока. |
| Чистый CPU          | ≈ то же                     | ≈ то же              | Ограничение — ядра процессора.                                                                 |
| Память (RSS)        | + 5‑10 MB                   | —                    | «временные» треды висят 5 с до idle‑timeout.                                             |


---

## 5. Исследование параметров (резюме)

| Параметр            | Наблюдение на GA401                                                                      |
| ------------------- | ---------------------------------------------------------------------------------------- |
| **corePoolSize**    | Выигрыш почти линейный до значения ≈ число ядер; дальше рост тормозит контекст‑свитчинг. |
| **maxPoolSize**     | Для I/O задач подходит `core × 2`; выше — прироста нет.                                  |
| **queueSize**       | 1 → 3 уменьшает задержку, > 3 даёт только больший резерв.                                |
| **keepAliveTime**   | 5 с — баланс между «лишние треды держатся» и «не плодим процесс».                        |
| **minSpareThreads** | 1 резервный поток убирает «холодный» старт; 2+ — эффекта нет.                            |

---

## 6. Примеры использования

```java
CustomThreadPoolExecutor pool = new CustomThreadPoolExecutor(
        2,              // corePoolSize
        4,              // maxPoolSize
        5, TimeUnit.SECONDS,
        3,              // queueSize per worker
        1,              // minSpareThreads
        "DemoPool");   // имя для логов

pool.execute(() -> {
    // работа задачи
});

pool.shutdown();
```

---

## 7. Логи (фрагмент)

```text
[ThreadFactory] Creating new thread: DemoPool-worker-3
[Pool] Task accepted into queue #2: Task@1e80bfe8
[Worker] DemoPool-worker-2 executes Task@1e80bfe8
[Rejected] Task Task@5e9f23b4 was rejected due to overload!
[Worker] DemoPool-worker-3 idle timeout (5 000 ms), stopping.
```

---

## 8. Как запустить

```
javac *.java
java Main          // демонстрирует обычный режим, перегрузку, shutdown()
```
